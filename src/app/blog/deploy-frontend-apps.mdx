export const metadata = {
  id: "deploy-frontend-apps",
  title: "Aumente su productividad: Cómo aprovechar AWS para implementar aplicaciones front-end de varios entornos",
  author: "SKOLZ",
  authorAvatar: "https://avatars.githubusercontent.com/u/1150154?v=4",
  date: "03/03/2024",
  cover: "https://images.unsplash.com/photo-1533643643812-4143839ba096?crop=entropy&cs=srgb&fm=jpg&ixid=M3wzMzc0NjN8MHwxfHNlYXJjaHwyfHxDb250YWluZXIlMjBxdWVyaWVzfGVufDB8fHx8MTcwNTY5NjAxNXww&ixlib=rb-4.0.3&w=800&h=800&auto=compress%2Cformat&fit=max",
  description: "En primer lugar, me gustaría daros un poco de contexto. Frontend Army trabaja con múltiples clientes en varios proyectos diferentes y cada uno de ellos tiene al menos tres entornos: desarrollo, staging y producción. Cada entorno utiliza un cubo S3 que está configurado para funcionar como un servicio de alojamiento web y CloudFront como CDN."

}

Hola a todos, hoy quiero compartir con ustedes cómo manejamos los despliegues front-end en Frontend Army.

En primer lugar, me gustaría daros un poco de contexto. Frontend Army trabaja con múltiples clientes en varios proyectos diferentes y cada uno de ellos tiene al menos tres entornos: desarrollo, staging y producción. Cada entorno utiliza un cubo S3 que está configurado para funcionar como un servicio de alojamiento web y CloudFront como CDN.

La configuración de nuestra infraestructura utiliza un script Terraform. El equipo de Front-End solo tiene que subir los archivos al bucket y usar la URL de CloudFront o alguna ruta personalizada creada usando Route 53 para acceder a ella. Ahora que sabes más sobre nuestra estructura, puede que estés al borde de tu asiento preguntándote: ¿Cómo subo mis cosas al cubo de S3? PACIENCIA TIENES QUE TENER, mi joven padawan.

Cómo evolucionamos

Hablemos de las formas que utilizábamos para subir nuestros archivos para entender por qué hemos optado por crear algo que simplifique nuestros despliegues. No hace mucho tiempo, utilizábamos la CLI de AWS en la mayoría de los casos. Iniciábamos sesión configurando nuestro ID de clave de acceso personal y nuestra clave de acceso secreta y, a continuación, utilizábamos el comando sync de S3 para subir los archivos.

Cuando desplegábamos un proyecto diferente, teníamos que cambiar las claves configuradas creando diferentes perfiles, seleccionando el correcto y luego ejecutando S3 sync. Eso era un poco molesto, así que algunos de nosotros terminamos subiendo los archivos manualmente. Sí, has leído bien, fuimos a la página de administración del bucket, borramos todo y arrastramos el contenido de la nueva compilación a la lista del bucket para subirlo. No estoy orgulloso de ello, pero así fue. Al final, todas esas inconsistencias terminaron en la creación de una herramienta que nos permitió manejar el despliegue de archivos a un cubo de S3 sólo mediante el uso de un archivo de configuración.

La biblioteca de deploy

This tool, like many others we have created to help us with a specific task, has its code in a github’s public repository. We also created an npm package to make it easier to manage the different versions. We encourage you to contribute to this development by creating a pull request or an issue.

This script uses a configuration file named aws.js in your project’s root directory where you define the different environments you are going to use with their respective deployment credentials, bucket, and region. It looks something like this:
```js
module.exports = {
  development: {
    accessKeyId: 'XXXXXXXXXXXXXX',
    secretAccessKey: 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX',
    region: 'us-east-1',
    bucket: 'bucket-name-dev'
  },
  stage: {
    accessKeyId: 'XXXXXXXXXXXXXX',
    secretAccessKey: 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX',
    region: 'us-east-1',
    bucket: 'bucket-name-stage'
  },
  production: {
    accessKeyId: 'XXXXXXXXXXXXXX',
    secretAccessKey: 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX',
    region: 'us-east-1',
    bucket: 'bucket-name-prod'
  }
};
```
Aparte de ese archivo, usted necesita cero configuración. Simplemente instala el paquete npm globalmente ejecutando

npm i -g aws-deploy-script-fe

Y cada vez que quieras desplegar, ejecuta el siguiente comando:

aws-deploy -e entorno -p ruta_de_tu_construcción_estática

La ruta de compilación por defecto es "build" y el entorno por defecto es desarrollo, así que también podrías eliminar eso del comando.

Problema de Cache

El uso de CloudFront nos proporcionó muchas mejoras de rendimiento, pero cada vez que despliegue código nuevo tendrá que crear una invalidación para decirle a CloudFront que vaya a buscar los nuevos datos del bucket, ya que el que está sirviendo ahora está obsoleto. Dado que las invalidaciones acaban costando dinero, hemos añadido la acción de desactivar la caché para el entorno de desarrollo a nuestro script terraform. También añadimos más funcionalidad a nuestra herramienta de despliegue especificando el ID de distribución de CloudFront y generando una invalidación en CloudFront tan pronto como se produce nuestro despliegue.

Esta funcionalidad se puede ver en el siguiente fragmento de código:
```js
module.exports = {
  development: {
    accessKeyId: 'XXXXXXXXXXXXXX',
    secretAccessKey: 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX',
    region: 'us-east-1',
    bucket: 'bucket-name-dev'
  },
  stage: {
    accessKeyId: 'XXXXXXXXXXXXXX',
    secretAccessKey: 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX',
    region: 'us-east-1',
    bucket: 'bucket-name-stage',
    distributionId: 'XXXXXXXXXXXXXX'
  },
  production: {
    accessKeyId: 'XXXXXXXXXXXXXX',
    secretAccessKey: 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX',
    region: 'us-east-1',
    bucket: 'bucket-name-prod',
    distributionId: 'XXXXXXXXXXXXXX'
  }
};
```


Y requiere que tengas una política específica en tu usuario aparte de las del S3.

Conclusión

Esto nos ha ayudado a estandarizar los despliegues en todos los frameworks front-end y añadiendo al gitignore el archivo aws.js podemos mantener nuestras credenciales a salvo. ¡Pruébalo y deja un comentario si quieres que mejoremos algo!
